leftItem(columnName) ::= <% lhs.add(new Column("$columnName$")); $\n$%>

rightItem(columnName) ::= <% rhs.add(new Column("$columnName$")); $\n$%>

cfdTemplate(CFDName, leftHandSide, rightHandSide, lExpression) ::= <<

/*
 * Copyright (C) Qatar Computing Research Institute, 2013.
 * All rights reserved.
 */
import qa.qcri.nadeef.core.datamodel.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * Pair Tuple CFD rule.
 *
 * @author Amr Ebaid (aebaid@qf.org.qa)
 * @author Si Yin (siyin@qf.org.qa)
 */
public class $CFDName$ extends PairTupleRule {
    protected List<Column> lhs;
    protected List<Column> rhs;
    protected List<SimpleExpression> leftFilterExpressions;
    protected HashMap<Column, SimpleExpression> filterCache;

    public $CFDName$() {}

    @Override
    public void initialize(String id, List<String> tableNames) {
        super.initialize(id, tableNames);

        lhs = new ArrayList<Column>();
        rhs = new ArrayList<Column>();
        leftFilterExpressions = new ArrayList<SimpleExpression>();
        filterCache = new HashMap<Column, SimpleExpression>();

        $leftHandSide:leftItem()$
        $rightHandSide:rightItem()$
        $lExpression$
    }

    /**
     * Default horizontal scope operation.
     * @param tupleCollections input tuple collections.
     * @return filtered tuple collection.
     */
    @Override
    public Collection<TupleCollection> horizontalScope(
        Collection<TupleCollection> tupleCollections
    ) {
        tupleCollections.iterator().next().project(lhs).project(rhs);
        return tupleCollections;
    }

    /**
     * Default vertical scope operation.
     * @param tupleCollections input tuple collections.
     * @return filtered tuple collection.
     */
    @Override
    public Collection<TupleCollection> verticalScope(
        Collection<TupleCollection> tupleCollections
    ) {
    	tupleCollections.iterator().next().filter(leftFilterExpressions);
        return tupleCollections;
    }
    
    /**
     * Default block operation.
     * @param tupleCollections a collection of tables.
     * @return a collection of blocked tables.
     */
    @Override
    public Collection<TupleCollection> block(Collection<TupleCollection> tupleCollections) {
        TupleCollection tupleCollection = tupleCollections.iterator().next();
        Collection<TupleCollection> groupResult = tupleCollection.groupOn(lhs);
        return groupResult;
    }

    /**
     * Default group operation.
     *
     * @param tuples input tuple
     * @return a group of tuple collection.
     */
    @Override
    public void iterator(TupleCollection tuples, IteratorStream output) {
        ArrayList<TuplePair> result = new ArrayList();
        tuples.orderBy(rhs);
        int pos1 = 0, pos2 = 0;
        boolean findViolation = false;

        // ---------------------------------------------------
        // two pointer loop via the block. Linear scan
        // ---------------------------------------------------
        while (pos1 < tuples.size()) {
            findViolation = false;
            for (pos2 = pos1 + 1; pos2 < tuples.size(); pos2 ++) {
                Tuple left = tuples.get(pos1);
                Tuple right = tuples.get(pos2);

                findViolation = !left.hasSameValue(right);

                // generates all the violations between pos1 - pos2.
                if (findViolation) {
                    for (int i = pos1; i < pos2; i ++) {
                        for (int j = pos2; j < tuples.size(); j++) {
                            TuplePair pair = new TuplePair(tuples.get(i), tuples.get(j));
                            output.put(pair);
                        }
                    }
                    break;
                }
            }
            pos1 = pos2;
        }
    }

    /**
     * Detect rule with many tuples.
     *
     * @param tuplePair input tuple.
     * @return Violation collection.
     */
    @Override
    public Collection<Violation> detect(TuplePair tuplePair) {
        List<Violation> result = new ArrayList();
        Tuple left = tuplePair.getLeft();
        Tuple right = tuplePair.getRight();
        Violation violation = new Violation(ruleName);
        violation.addTuple(left);
        violation.addTuple(right);
        result.add(violation);
        return result;
    }

    /**
     * Repair of this rule.
     *
     * @param violation violation input.
     * @return a candidate fix.
     */
    @Override
    public Collection<Fix> repair(Violation violation) {
        List<Fix> result = new ArrayList();
        List<Cell> cells = new ArrayList(violation.getCells());
        HashMap<Column, Cell> candidates = new HashMap();

        Fix fix;
        Fix.Builder builder = new Fix.Builder(violation);
        for (Cell cell : cells) {
            Column column = cell.getColumn();
            if (rhs.contains(column)) {
                if (filterCache.containsKey(column)) {
                    // if the right hand is in the filter expression, we assign it a constant.
                    SimpleExpression filter = filterCache.get(column);
                    fix = builder.left(cell).right(filter.getValue()).build();
                    result.add(fix);
                } else if (candidates.containsKey(column)) {
                    // if the right hand is already found out in another tuple
                    Cell right = candidates.get(column);
                    fix = builder.left(cell).right(right).build();
                    result.add(fix);
                } else {
                    // it is the first time of this cell shown up, put it in the candidate and
                    // wait for the next one shown up.
                    candidates.put(column, cell);
                }
            }
        }
        return result;
    }
}
>>