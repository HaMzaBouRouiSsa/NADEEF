leftItem(columnName) ::= <% lhs.add(new Column("$columnName$")); $\n$%>

rightItem(columnName) ::= <% rhs.add(new Column("$columnName$")); $\n$%>

expressionItem(columnName, value) ::= <<
filterExpressions.add(SimpleExpression.newEqual(new Column("$columnName$"), "$value$"));$\n$
>>

cfdTemplate(CFDName, leftHandSide, rightHandSide, expression) ::= <<

/*
 * Copyright (C) Qatar Computing Research Institute, 2013.
 * All rights reserved.
 */
import qa.qcri.nadeef.core.datamodel.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * CFD rule.
 */
public class $CFDName$ extends PairTupleRule {
    protected List<Column> lhs;
    protected List<Column> rhs;
    protected List<SimpleExpression> filterExpressions;
    protected HashMap<Column, SimpleExpression> filterCache;

    public $CFDName$() {}

    @Override
    public void initialize(String id, List<String> tableNames) {
        super.initialize(id, tableNames);

        lhs = new ArrayList<Column>();
        rhs = new ArrayList<Column>();
        filterExpressions = new ArrayList<SimpleExpression>();
        filterCache = new HashMap<Column, SimpleExpression>();

        $leftHandSide:leftItem()$
        $rightHandSide:rightItem()$
        $expression$
    }

    /**
     * Default horizontal scope operation.
     * @param tupleCollection input tuple collections.
     * @return filtered tuple collection.
     */
    @Override
    public Collection<TupleCollection> horizontalScope(
        Collection<TupleCollection> tupleCollections
    ) {
        tupleCollections.iterator().next().project(lhs).project(rhs);
        return tupleCollections;
    }

    /**
     * Default vertical scope operation.
     * @param tupleCollection input tuple collections.
     * @return filtered tuple collection.
     */
    @Override
    public Collection<TupleCollection> verticalScope(
        Collection<TupleCollection> tupleCollections
    ) {
        tupleCollections.iterator().next().filter(filterExpressions);
        return tupleCollections;
    }

    /**
     * Detect rule with many tuples.
     *
     * @param tuplePair input tuple.
     * @return Violation collection.
     */
    @Override
    public Collection<Violation> detect(TuplePair tuplePair) {
        Tuple left = tuplePair.getLeft();
        Tuple right = tuplePair.getRight();

        Column[] rhsColumns = rhs.toArray(new Column[rhs.size()]);
        List<Violation> result = new ArrayList();
        for (Column column : rhsColumns) {
            Object lvalue = left.get(column);
            Object rvalue = right.get(column);

            if (!lvalue.equals(rvalue)) {
                Violation violation = new Violation(id);
                violation.addTuple(left);
                violation.addTuple(right);
                result.add(violation);
                break;
            }
        }

        return result;
    }

    /**
     * Repair of this rule.
     *
     * @param violation violation input.
     * @return a candidate fix.
     */
    @Override
    public Collection<Fix> repair(Violation violation) {
        List<Fix> result = new ArrayList();
        List<Cell> cells = new ArrayList(violation.getCells());
        HashMap<Column, Cell> candidates = new HashMap();

        Fix fix;
        Fix.Builder builder = new Fix.Builder(violation);
        for (Cell cell : cells) {
            Column column = cell.getColumn();
            if (rhs.contains(column)) {
                if (filterCache.containsKey(column)) {
                    // if the right hand is in the filter expression, we assign it a constant.
                    SimpleExpression filter = filterCache.get(column);
                    fix = builder.left(cell).right(filter.getValue()).build();
                    result.add(fix);
                } else if (candidates.containsKey(column)) {
                    // if the right hand is already found out in another tuple
                    Cell right = candidates.get(column);
                    fix = builder.left(cell).right(right).build();
                    result.add(fix);
                } else {
                    // it is the first time of this cell shown up, put it in the candidate and
                    // wait for the next one shown up.
                    candidates.put(column, cell);
                }
            }
        }
        return result;
    }
}
>>